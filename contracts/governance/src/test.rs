#![cfg(test)]
extern crate alloc;

use super::*;
use soroban_sdk::{
    contract, contractimpl, contracttype,
    testutils::{Address as _, Ledger, LedgerInfo},
    token, Address, Env, String, Symbol, Val, Vec,
};

// Mock token contract for testing with mint functionality
#[contract]
pub struct MockToken;

#[contracttype]
#[derive(Clone, Debug, Eq, PartialEq)]
pub enum DataKey {
    Admin,
    Balances(Address),
}

#[contractimpl]
impl MockToken {
    pub fn initialize(env: Env, admin: Address) {
        if env.storage().instance().has(&DataKey::Admin) {
            panic!("Already initialized");
        }
        env.storage().instance().set(&DataKey::Admin, &admin);
    }

    pub fn mint(env: Env, to: Address, amount: i128) {
        let admin: Address = env.storage().instance().get(&DataKey::Admin).unwrap();
        admin.require_auth();

        let balance_key = DataKey::Balances(to.clone());
        let current_balance: i128 = env.storage().instance().get(&balance_key).unwrap_or(0);
        env.storage()
            .instance()
            .set(&balance_key, &(current_balance + amount));
    }

    pub fn balance(env: Env, id: Address) -> i128 {
        let balance_key = DataKey::Balances(id);
        env.storage().instance().get(&balance_key).unwrap_or(0)
    }

    pub fn transfer(env: Env, from: Address, to: Address, amount: i128) {
        from.require_auth();

        let from_key = DataKey::Balances(from.clone());
        let from_balance: i128 = env.storage().instance().get(&from_key).unwrap_or(0);
        if from_balance < amount {
            panic!("Insufficient balance");
        }
        env.storage()
            .instance()
            .set(&from_key, &(from_balance - amount));

        let to_key = DataKey::Balances(to.clone());
        let to_balance: i128 = env.storage().instance().get(&to_key).unwrap_or(0);
        env.storage()
            .instance()
            .set(&to_key, &(to_balance + amount));
    }

    pub fn approve(
        env: Env,
        from: Address,
        spender: Address,
        amount: i128,
        expiration_ledger: u32,
    ) {
        from.require_auth();
        // Simplified approval for testing
    }

    pub fn allowance(env: Env, from: Address, spender: Address) -> i128 {
        0 // Simplified for testing
    }
}

// MockTokenClient is automatically generated by #[contract] macro

// Mock target contract for proposal execution tests
#[contract]
pub struct MockTargetContract;

#[contractimpl]
impl MockTargetContract {
    pub fn update_parameter(env: Env, name: String, value: String) {
        // Mock function for parameter updates
        env.storage().instance().set(&name, &value);
    }
}

// MockTargetContractClient is automatically generated by #[contract] macro

fn create_token_contract(e: &Env, admin: &Address) -> Address {
    let contract_id = e.register_contract(None, MockToken);
    let mock_token = MockTokenClient::new(e, &contract_id);
    e.mock_all_auths();
    mock_token.initialize(&admin);
    contract_id
}

fn create_governance_contract(e: &Env) -> Address {
    e.register_contract(None, Governance)
}

fn setup_governance(
    e: &Env,
) -> (
    GovernanceClient<'static>,
    Address,
    Address,
    MockTokenClient<'static>,
) {
    let admin = Address::generate(e);
    let governance_token = create_token_contract(e, &admin);
    let governance = create_governance_contract(e);

    let gov_client = GovernanceClient::new(e, &governance);
    let mock_token_client = MockTokenClient::new(e, &governance_token);

    e.mock_all_auths();
    gov_client.init_contract(
        &admin,
        &governance_token,
        &None::<u32>,
        &None::<u32>,
        &None::<u64>,
        &None::<u64>,
        &None::<u128>,
    );

    (gov_client, admin, governance_token, mock_token_client)
}

// Helper to simulate minting tokens in test environment
// Note: StellarAsset contracts don't have a mint method in test environment
// This is a workaround - in production, tokens would be minted by the issuer
fn simulate_mint(e: &Env, token: &Address, admin: &Address, to: &Address, amount: i128) {
    // In test environment, we can't actually mint StellarAsset tokens
    // For testing purposes, we'll skip this and assume tokens exist
    // In a real test setup, you would use a mock token contract or proper minting
    // For now, tests that require tokens will need to be adjusted
}

// ============================================================================
// 1. Unit tests for voting power calculations
// ============================================================================

#[test]
fn test_voting_power_base_tokens_only() {
    let e = Env::default();
    e.mock_all_auths();
    let (gov_client, admin, governance_token, token_client) = setup_governance(&e);

    let user = Address::generate(&e);
    token_client.mint(&user, &10000);

    let power = gov_client.get_vote_power(&user);
    assert_eq!(power, 10000);
}

#[test]
fn test_voting_power_with_escrow() {
    let e = Env::default();
    e.mock_all_auths();
    e.ledger().set(LedgerInfo {
        timestamp: 1000,
        protocol_version: 20,
        sequence_number: 10,
        network_id: Default::default(),
        base_reserve: 10,
        max_entry_ttl: 31536000,
        min_persistent_entry_ttl: 2592000,
        min_temp_entry_ttl: 16,
    });

    let (gov_client, admin, governance_token, token_client) = setup_governance(&e);
    let user = Address::generate(&e);

    token_client.mint(&user, &20000);
    gov_client.lock_for_escrow(&user, &10000, &4); // 4 weeks = 2x

    let power = gov_client.get_vote_power(&user);
    // Base: 10000 (remaining), Escrow: 10000 * 2 = 20000
    assert_eq!(power, 30000);
}

#[test]
fn test_voting_power_with_delegation() {
    let e = Env::default();
    e.mock_all_auths();
    let (gov_client, admin, governance_token, token_client) = setup_governance(&e);

    let delegator = Address::generate(&e);
    let delegatee = Address::generate(&e);

    e.mock_all_auths();
    token_client.mint(&delegator, &10000);
    gov_client.delegate_voting_power(&delegator, &delegatee, &5000);

    let delegator_power = gov_client.get_vote_power(&delegator);
    let delegatee_power = gov_client.get_vote_power(&delegatee);

    assert_eq!(delegator_power, 5000); // Remaining after delegation
    assert_eq!(delegatee_power, 5000); // Received from delegator
}

#[test]
fn test_voting_power_combined() {
    let e = Env::default();
    e.mock_all_auths();
    e.ledger().set(LedgerInfo {
        timestamp: 1000,
        protocol_version: 20,
        sequence_number: 10,
        network_id: Default::default(),
        base_reserve: 10,
        max_entry_ttl: 31536000,
        min_persistent_entry_ttl: 2592000,
        min_temp_entry_ttl: 16,
    });

    let (gov_client, admin, governance_token, token_client) = setup_governance(&e);

    let user1 = Address::generate(&e);
    let user2 = Address::generate(&e);

    e.mock_all_auths();
    token_client.mint(&user1, &20000);
    token_client.mint(&user2, &10000);

    gov_client.lock_for_escrow(&user1, &5000, &26); // 26 weeks = 3x
    gov_client.delegate_voting_power(&user2, &user1, &5000);

    let power = gov_client.get_vote_power(&user1);
    // Base: 15000 (20000 - 5000 locked)
    // Escrow: 5000 * multiplier(26 weeks) / 10000
    // Multiplier for 26 weeks: 20000 + ((26-4)*20000)/48 = 20000 + 9166.67 = 29167
    // Escrow power: 5000 * 29167 / 10000 = 14583
    // Delegated: 5000
    // Total: 15000 + 14583 + 5000 = 34583
    assert_eq!(power, 34583);
}

#[test]
fn test_voting_power_escrow_expired() {
    let e = Env::default();
    e.mock_all_auths();
    e.ledger().set(LedgerInfo {
        timestamp: 1000,
        protocol_version: 20,
        sequence_number: 10,
        network_id: Default::default(),
        base_reserve: 10,
        max_entry_ttl: 31536000,
        min_persistent_entry_ttl: 2592000,
        min_temp_entry_ttl: 16,
    });

    let (gov_client, admin, governance_token, token_client) = setup_governance(&e);
    let user = Address::generate(&e);

    token_client.mint(&user, &20000);
    gov_client.lock_for_escrow(&user, &10000, &4);

    e.ledger().set(LedgerInfo {
        timestamp: 1000 + (4 * 7 * 24 * 60 * 60) + 1,
        protocol_version: 20,
        sequence_number: 20,
        network_id: Default::default(),
        base_reserve: 10,
        max_entry_ttl: 31536000,
        min_persistent_entry_ttl: 2592000,
        min_temp_entry_ttl: 16,
    });

    let power = gov_client.get_vote_power(&user);
    assert_eq!(power, 10000); // Only base, escrow expired
}

// ============================================================================
// 2. Tests for delegation and re-delegation
// ============================================================================

#[test]
fn test_simple_delegation() {
    let e = Env::default();
    e.mock_all_auths();
    let (gov_client, admin, governance_token, token_client) = setup_governance(&e);

    let delegator = Address::generate(&e);
    let delegatee = Address::generate(&e);

    e.mock_all_auths();
    token_client.mint(&delegator, &10000);
    gov_client.delegate_voting_power(&delegator, &delegatee, &5000);

    let delegation = gov_client.get_delegation(&delegator);
    assert!(delegation.is_some());
    let del = delegation.unwrap();
    assert_eq!(del.delegatee, delegatee);
    assert_eq!(del.amount, 5000);
}

#[test]
fn test_re_delegation() {
    let e = Env::default();
    e.mock_all_auths();
    let (gov_client, admin, governance_token, token_client) = setup_governance(&e);

    let alice = Address::generate(&e);
    let bob = Address::generate(&e);
    let charlie = Address::generate(&e);

    e.mock_all_auths();
    token_client.mint(&alice, &10000);
    token_client.mint(&bob, &5000);

    gov_client.delegate_voting_power(&alice, &bob, &5000);
    gov_client.delegate_voting_power(&bob, &charlie, &3000);

    let bob_power = gov_client.get_vote_power(&bob);
    let charlie_power = gov_client.get_vote_power(&charlie);

    assert_eq!(bob_power, 7000); // 5000 base + 5000 delegated - 3000 re-delegated = 7000
    assert_eq!(charlie_power, 3000); // Received from bob
}

#[test]
fn test_change_delegation() {
    let e = Env::default();
    e.mock_all_auths();
    let (gov_client, admin, governance_token, token_client) = setup_governance(&e);

    let delegator = Address::generate(&e);
    let delegatee1 = Address::generate(&e);
    let delegatee2 = Address::generate(&e);

    e.mock_all_auths();
    token_client.mint(&delegator, &10000);
    gov_client.delegate_voting_power(&delegator, &delegatee1, &5000);
    gov_client.delegate_voting_power(&delegator, &delegatee2, &5000);

    let delegation = gov_client.get_delegation(&delegator);
    assert_eq!(delegation.unwrap().delegatee, delegatee2);
}

#[test]
fn test_undelegate() {
    let e = Env::default();
    e.mock_all_auths();
    let (gov_client, admin, governance_token, token_client) = setup_governance(&e);

    let delegator = Address::generate(&e);
    let delegatee = Address::generate(&e);

    e.mock_all_auths();
    token_client.mint(&delegator, &10000);
    gov_client.delegate_voting_power(&delegator, &delegatee, &5000);
    gov_client.undelegate_voting_power(&delegator);

    let delegation = gov_client.get_delegation(&delegator);
    assert!(delegation.is_none());
}

#[test]
#[should_panic(expected = "Cannot delegate to self")]
fn test_delegate_to_self() {
    let e = Env::default();
    e.mock_all_auths();
    let (gov_client, admin, governance_token, token_client) = setup_governance(&e);

    let user = Address::generate(&e);
    token_client.mint(&user, &10000);
    gov_client.delegate_voting_power(&user, &user, &5000);
}

// ============================================================================
// 3. Tests for vote escrow lock mechanisms
// ============================================================================

#[test]
fn test_escrow_multipliers() {
    let e = Env::default();
    e.mock_all_auths();
    e.ledger().set(LedgerInfo {
        timestamp: 1000,
        protocol_version: 20,
        sequence_number: 10,
        network_id: Default::default(),
        base_reserve: 10,
        max_entry_ttl: 31536000,
        min_persistent_entry_ttl: 2592000,
        min_temp_entry_ttl: 16,
    });

    let (gov_client, admin, governance_token, token_client) = setup_governance(&e);
    let user = Address::generate(&e);
    e.mock_all_auths();
    token_client.mint(&user, &50000);

    gov_client.lock_for_escrow(&user, &10000, &4); // 4 weeks = 2x
    let escrow1 = gov_client.get_vote_escrow(&user).unwrap();
    assert_eq!(escrow1.multiplier, 20000);

    let user2 = Address::generate(&e);
    e.mock_all_auths();
    token_client.mint(&user2, &50000);
    gov_client.lock_for_escrow(&user2, &10000, &52); // 52 weeks = 4x
    let escrow2 = gov_client.get_vote_escrow(&user2).unwrap();
    assert_eq!(escrow2.multiplier, 40000);

    let user3 = Address::generate(&e);
    e.mock_all_auths();
    token_client.mint(&user3, &50000);
    gov_client.lock_for_escrow(&user3, &10000, &28); // 28 weeks = 3x
    let escrow3 = gov_client.get_vote_escrow(&user3).unwrap();
    assert_eq!(escrow3.multiplier, 30000);
}

#[test]
fn test_escrow_add_to_existing() {
    let e = Env::default();
    e.mock_all_auths();
    e.ledger().set(LedgerInfo {
        timestamp: 1000,
        protocol_version: 20,
        sequence_number: 10,
        network_id: Default::default(),
        base_reserve: 10,
        max_entry_ttl: 31536000,
        min_persistent_entry_ttl: 2592000,
        min_temp_entry_ttl: 16,
    });

    let (gov_client, admin, governance_token, token_client) = setup_governance(&e);
    let user = Address::generate(&e);
    e.mock_all_auths();
    token_client.mint(&user, &50000);

    gov_client.lock_for_escrow(&user, &10000, &4);
    gov_client.lock_for_escrow(&user, &5000, &8);

    let escrow = gov_client.get_vote_escrow(&user).unwrap();
    assert_eq!(escrow.amount, 15000);
}

#[test]
fn test_unlock_escrow() {
    let e = Env::default();
    e.mock_all_auths();
    e.ledger().set(LedgerInfo {
        timestamp: 1000,
        protocol_version: 20,
        sequence_number: 10,
        network_id: Default::default(),
        base_reserve: 10,
        max_entry_ttl: 31536000,
        min_persistent_entry_ttl: 2592000,
        min_temp_entry_ttl: 16,
    });

    let (gov_client, _, governance_token, token_client) = setup_governance(&e);
    let user = Address::generate(&e);
    token_client.mint(&user, &20000);

    let initial_balance = token_client.balance(&user);
    gov_client.lock_for_escrow(&user, &10000, &4);

    let lock_duration = 4 * 7 * 24 * 60 * 60;
    e.ledger().set(LedgerInfo {
        timestamp: 1000 + lock_duration + 1,
        protocol_version: 20,
        sequence_number: 20,
        network_id: Default::default(),
        base_reserve: 10,
        max_entry_ttl: 31536000,
        min_persistent_entry_ttl: 2592000,
        min_temp_entry_ttl: 16,
    });

    gov_client.unlock_escrow(&user);
    let final_balance = token_client.balance(&user);
    assert_eq!(final_balance, initial_balance);
}

#[test]
#[should_panic(expected = "Escrow is still locked")]
fn test_unlock_before_expiry() {
    let e = Env::default();
    e.mock_all_auths();
    e.ledger().set(LedgerInfo {
        timestamp: 1000,
        protocol_version: 20,
        sequence_number: 10,
        network_id: Default::default(),
        base_reserve: 10,
        max_entry_ttl: 31536000,
        min_persistent_entry_ttl: 2592000,
        min_temp_entry_ttl: 16,
    });

    let (gov_client, admin, governance_token, token_client) = setup_governance(&e);
    let user = Address::generate(&e);
    token_client.mint(&user, &20000);

    gov_client.lock_for_escrow(&user, &10000, &4);
    gov_client.unlock_escrow(&user);
}

// ============================================================================
// 4. Integration tests for full proposal lifecycle
// ============================================================================

#[test]
fn test_full_proposal_lifecycle() {
    let e = Env::default();
    e.mock_all_auths();
    e.ledger().set(LedgerInfo {
        timestamp: 1000,
        protocol_version: 20,
        sequence_number: 10,
        network_id: Default::default(),
        base_reserve: 10,
        max_entry_ttl: 31536000,
        min_persistent_entry_ttl: 2592000,
        min_temp_entry_ttl: 16,
    });

    let (gov_client, admin, governance_token, token_client) = setup_governance(&e);

    let proposer = Address::generate(&e);
    let voter1 = Address::generate(&e);
    let voter2 = Address::generate(&e);

    e.mock_all_auths();
    token_client.mint(&proposer, &10000);
    token_client.mint(&voter1, &50000);
    token_client.mint(&voter2, &30000);

    gov_client.update_circulating_voting_power(&admin, &100000u128);

    let target_contract = e.register_contract(None, MockTargetContract);
    let params = ProposalParameters {
        name: String::from_str(&e, "test_param"),
        value: String::from_str(&e, "test_value"),
    };
    let title = String::from_str(&e, "Test Proposal");
    let description = String::from_str(&e, "Full lifecycle test");
    let voting_period = 7 * 24 * 60 * 60; // 7 days (minimum valid period)

    let proposal_id = gov_client.create_proposal(
        &proposer,
        &title,
        &description,
        &voting_period,
        &ProposalType::ParameterChange,
        &Some(params),
        &Some(target_contract),
        &Some(Symbol::new(&e, "update_parameter")),
        &None::<Vec<Val>>,
    );

    assert_eq!(proposal_id, 1);

    let proposal = gov_client.get_proposal(&proposal_id).unwrap();
    assert_eq!(proposal.status, ProposalStatus::Active);

    gov_client.cast_vote(&voter1, &proposal_id, &VoteType::For);
    gov_client.cast_vote(&voter2, &proposal_id, &VoteType::For);

    e.ledger().set(LedgerInfo {
        timestamp: 1000 + voting_period + 1,
        protocol_version: 20,
        sequence_number: 20,
        network_id: Default::default(),
        base_reserve: 10,
        max_entry_ttl: 31536000,
        min_persistent_entry_ttl: 2592000,
        min_temp_entry_ttl: 16,
    });

    gov_client.update_proposal_status(&proposal_id);

    let proposal = gov_client.get_proposal(&proposal_id).unwrap();
    assert_eq!(proposal.status, ProposalStatus::Passed);

    let executor = Address::generate(&e);
    gov_client.execute_proposal(&executor, &proposal_id);

    let proposal = gov_client.get_proposal(&proposal_id).unwrap();
    assert_eq!(proposal.status, ProposalStatus::Executed);
}

// ============================================================================
// 5. Tests for voting fairness
// ============================================================================

#[test]
#[should_panic(expected = "Already voted")]
fn test_no_double_voting() {
    let e = Env::default();
    e.mock_all_auths();
    e.ledger().set(LedgerInfo {
        timestamp: 1000,
        protocol_version: 20,
        sequence_number: 10,
        network_id: Default::default(),
        base_reserve: 10,
        max_entry_ttl: 31536000,
        min_persistent_entry_ttl: 2592000,
        min_temp_entry_ttl: 16,
    });

    let (gov_client, admin, governance_token, token_client) = setup_governance(&e);
    let proposer = Address::generate(&e);
    let voter = Address::generate(&e);

    e.mock_all_auths();
    token_client.mint(&proposer, &10000);
    token_client.mint(&voter, &5000);

    let proposal_id = gov_client.create_proposal(
        &proposer,
        &String::from_str(&e, "Test"),
        &String::from_str(&e, "Test"),
        &(7 * 24 * 60 * 60),
        &ProposalType::ParameterChange,
        &None::<ProposalParameters>,
        &None::<Address>,
        &None::<Symbol>,
        &None::<Vec<Val>>,
    );

    gov_client.cast_vote(&voter, &proposal_id, &VoteType::For);
    gov_client.cast_vote(&voter, &proposal_id, &VoteType::Against);
}

#[test]
#[should_panic(expected = "Voting has not started yet")]
fn test_vote_before_start() {
    let e = Env::default();
    e.mock_all_auths();
    e.ledger().set(LedgerInfo {
        timestamp: 1000,
        protocol_version: 20,
        sequence_number: 10,
        network_id: Default::default(),
        base_reserve: 10,
        max_entry_ttl: 31536000,
        min_persistent_entry_ttl: 2592000,
        min_temp_entry_ttl: 16,
    });

    let (gov_client, admin, governance_token, token_client) = setup_governance(&e);
    let proposer = Address::generate(&e);
    let voter = Address::generate(&e);

    e.mock_all_auths();
    token_client.mint(&proposer, &10000);
    token_client.mint(&voter, &5000);

    let proposal_id = gov_client.create_proposal(
        &proposer,
        &String::from_str(&e, "Test"),
        &String::from_str(&e, "Test"),
        &(7 * 24 * 60 * 60),
        &ProposalType::ParameterChange,
        &None::<ProposalParameters>,
        &None::<Address>,
        &None::<Symbol>,
        &None::<Vec<Val>>,
    );

    e.ledger().set(LedgerInfo {
        timestamp: 999,
        protocol_version: 20,
        sequence_number: 9,
        network_id: Default::default(),
        base_reserve: 10,
        max_entry_ttl: 31536000,
        min_persistent_entry_ttl: 2592000,
        min_temp_entry_ttl: 16,
    });

    gov_client.cast_vote(&voter, &proposal_id, &VoteType::For);
}

#[test]
#[should_panic(expected = "Voting period has ended")]
fn test_vote_after_end() {
    let e = Env::default();
    e.mock_all_auths();
    e.ledger().set(LedgerInfo {
        timestamp: 1000,
        protocol_version: 20,
        sequence_number: 10,
        network_id: Default::default(),
        base_reserve: 10,
        max_entry_ttl: 31536000,
        min_persistent_entry_ttl: 2592000,
        min_temp_entry_ttl: 16,
    });

    let (gov_client, admin, governance_token, token_client) = setup_governance(&e);
    let proposer = Address::generate(&e);
    let voter = Address::generate(&e);

    e.mock_all_auths();
    token_client.mint(&proposer, &10000);
    token_client.mint(&voter, &5000);

    let voting_period = 7 * 24 * 60 * 60; // 7 days (minimum valid period)
    let proposal_id = gov_client.create_proposal(
        &proposer,
        &String::from_str(&e, "Test"),
        &String::from_str(&e, "Test"),
        &voting_period,
        &ProposalType::ParameterChange,
        &None::<ProposalParameters>,
        &None::<Address>,
        &None::<Symbol>,
        &None::<Vec<Val>>,
    );

    e.ledger().set(LedgerInfo {
        timestamp: 1000 + voting_period + 1,
        protocol_version: 20,
        sequence_number: 20,
        network_id: Default::default(),
        base_reserve: 10,
        max_entry_ttl: 31536000,
        min_persistent_entry_ttl: 2592000,
        min_temp_entry_ttl: 16,
    });

    gov_client.cast_vote(&voter, &proposal_id, &VoteType::For);
}

#[test]
#[should_panic(expected = "No voting power")]
fn test_vote_without_power() {
    let e = Env::default();
    e.mock_all_auths();
    e.ledger().set(LedgerInfo {
        timestamp: 1000,
        protocol_version: 20,
        sequence_number: 10,
        network_id: Default::default(),
        base_reserve: 10,
        max_entry_ttl: 31536000,
        min_persistent_entry_ttl: 2592000,
        min_temp_entry_ttl: 16,
    });

    let (gov_client, admin, governance_token, token_client) = setup_governance(&e);
    let proposer = Address::generate(&e);
    let voter = Address::generate(&e);

    e.mock_all_auths();
    token_client.mint(&proposer, &10000);

    let proposal_id = gov_client.create_proposal(
        &proposer,
        &String::from_str(&e, "Test"),
        &String::from_str(&e, "Test"),
        &(7 * 24 * 60 * 60),
        &ProposalType::ParameterChange,
        &None::<ProposalParameters>,
        &None::<Address>,
        &None::<Symbol>,
        &None::<Vec<Val>>,
    );

    gov_client.cast_vote(&voter, &proposal_id, &VoteType::For);
}

// ============================================================================
// 6. Tests for proposal execution
// ============================================================================

#[test]
fn test_execute_parameter_change_proposal() {
    let e = Env::default();
    e.mock_all_auths();
    e.ledger().set(LedgerInfo {
        timestamp: 1000,
        protocol_version: 20,
        sequence_number: 10,
        network_id: Default::default(),
        base_reserve: 10,
        max_entry_ttl: 31536000,
        min_persistent_entry_ttl: 2592000,
        min_temp_entry_ttl: 16,
    });

    let (gov_client, admin, governance_token, token_client) = setup_governance(&e);
    let proposer = Address::generate(&e);
    let voter = Address::generate(&e);

    e.mock_all_auths();
    token_client.mint(&proposer, &10000);
    token_client.mint(&voter, &50000);

    gov_client.update_circulating_voting_power(&admin, &100000u128);

    let target_contract = e.register_contract(None, MockTargetContract);
    let params = ProposalParameters {
        name: String::from_str(&e, "fee_rate"),
        value: String::from_str(&e, "500"),
    };

    let voting_period = 7 * 24 * 60 * 60; // 7 days (minimum valid period)
    let proposal_id = gov_client.create_proposal(
        &proposer,
        &String::from_str(&e, "Change Fee"),
        &String::from_str(&e, "Update fee rate"),
        &voting_period,
        &ProposalType::ParameterChange,
        &Some(params),
        &Some(target_contract),
        &Some(Symbol::new(&e, "update_parameter")),
        &None::<Vec<Val>>,
    );

    gov_client.cast_vote(&voter, &proposal_id, &VoteType::For);

    e.ledger().set(LedgerInfo {
        timestamp: 1000 + voting_period + 1,
        protocol_version: 20,
        sequence_number: 20,
        network_id: Default::default(),
        base_reserve: 10,
        max_entry_ttl: 31536000,
        min_persistent_entry_ttl: 2592000,
        min_temp_entry_ttl: 16,
    });

    gov_client.update_proposal_status(&proposal_id);

    let executor = Address::generate(&e);
    gov_client.execute_proposal(&executor, &proposal_id);

    let proposal = gov_client.get_proposal(&proposal_id).unwrap();
    assert_eq!(proposal.status, ProposalStatus::Executed);
}

#[test]
#[should_panic(expected = "Proposal has not passed")]
fn test_execute_before_passing() {
    let e = Env::default();
    e.mock_all_auths();
    e.ledger().set(LedgerInfo {
        timestamp: 1000,
        protocol_version: 20,
        sequence_number: 10,
        network_id: Default::default(),
        base_reserve: 10,
        max_entry_ttl: 31536000,
        min_persistent_entry_ttl: 2592000,
        min_temp_entry_ttl: 16,
    });

    let (gov_client, admin, governance_token, token_client) = setup_governance(&e);
    let proposer = Address::generate(&e);

    e.mock_all_auths();
    token_client.mint(&proposer, &10000);

    let proposal_id = gov_client.create_proposal(
        &proposer,
        &String::from_str(&e, "Test"),
        &String::from_str(&e, "Test"),
        &(7 * 24 * 60 * 60),
        &ProposalType::ParameterChange,
        &None::<ProposalParameters>,
        &None::<Address>,
        &None::<Symbol>,
        &None::<Vec<Val>>,
    );

    let executor = Address::generate(&e);
    gov_client.execute_proposal(&executor, &proposal_id);
}

// ============================================================================
// 7. Stress tests: many proposals, many voters
// ============================================================================

#[test]
fn test_many_proposals() {
    let e = Env::default();
    e.mock_all_auths();
    e.ledger().set(LedgerInfo {
        timestamp: 1000,
        protocol_version: 20,
        sequence_number: 10,
        network_id: Default::default(),
        base_reserve: 10,
        max_entry_ttl: 31536000,
        min_persistent_entry_ttl: 2592000,
        min_temp_entry_ttl: 16,
    });

    let (gov_client, admin, governance_token, token_client) = setup_governance(&e);
    let proposer = Address::generate(&e);
    e.mock_all_auths();
    token_client.mint(&proposer, &1000000);

    for i in 1..=10 {
        let title = String::from_str(&e, &alloc::format!("Proposal {}", i));
        let description = String::from_str(&e, &alloc::format!("Description {}", i));
        let proposal_id = gov_client.create_proposal(
            &proposer,
            &title,
            &description,
            &(7 * 24 * 60 * 60),
            &ProposalType::ParameterChange,
            &None::<ProposalParameters>,
            &None::<Address>,
            &None::<Symbol>,
            &None::<Vec<Val>>,
        );
        assert_eq!(proposal_id, i);
    }

    let active = gov_client.get_active_proposals();
    assert_eq!(active.len(), 10);
}

#[test]
fn test_many_voters() {
    let e = Env::default();
    e.mock_all_auths();
    e.ledger().set(LedgerInfo {
        timestamp: 1000,
        protocol_version: 20,
        sequence_number: 10,
        network_id: Default::default(),
        base_reserve: 10,
        max_entry_ttl: 31536000,
        min_persistent_entry_ttl: 2592000,
        min_temp_entry_ttl: 16,
    });

    let (gov_client, admin, governance_token, token_client) = setup_governance(&e);
    let proposer = Address::generate(&e);
    e.mock_all_auths();
    token_client.mint(&proposer, &10000);

    let proposal_id = gov_client.create_proposal(
        &proposer,
        &String::from_str(&e, "Test"),
        &String::from_str(&e, "Test"),
        &(7 * 24 * 60 * 60),
        &ProposalType::ParameterChange,
        &None::<ProposalParameters>,
        &None::<Address>,
        &None::<Symbol>,
        &None::<Vec<Val>>,
    );

    let mut total_votes = 0u128;
    for i in 0..20 {
        let voter = Address::generate(&e);
        e.mock_all_auths();
        token_client.mint(&voter, &(1000 + i * 100));
        gov_client.cast_vote(&voter, &proposal_id, &VoteType::For);
        total_votes += (1000 + i * 100) as u128;
    }

    let proposal = gov_client.get_proposal(&proposal_id).unwrap();
    assert_eq!(proposal.votes_for, total_votes);
}

// ============================================================================
// 8. Edge cases: circulating voting power edge cases
// ============================================================================

#[test]
fn test_quorum_edge_case() {
    let e = Env::default();
    e.mock_all_auths();
    e.ledger().set(LedgerInfo {
        timestamp: 1000,
        protocol_version: 20,
        sequence_number: 10,
        network_id: Default::default(),
        base_reserve: 10,
        max_entry_ttl: 31536000,
        min_persistent_entry_ttl: 2592000,
        min_temp_entry_ttl: 16,
    });

    let (gov_client, admin, governance_token, token_client) = setup_governance(&e);
    let proposer = Address::generate(&e);
    let voter = Address::generate(&e);

    e.mock_all_auths();
    token_client.mint(&proposer, &10000);
    token_client.mint(&voter, &30000);

    gov_client.update_circulating_voting_power(&admin, &100000u128);

    let voting_period = 7 * 24 * 60 * 60; // 7 days (minimum valid period)
    let proposal_id = gov_client.create_proposal(
        &proposer,
        &String::from_str(&e, "Test"),
        &String::from_str(&e, "Test"),
        &voting_period,
        &ProposalType::ParameterChange,
        &None::<ProposalParameters>,
        &None::<Address>,
        &None::<Symbol>,
        &None::<Vec<Val>>,
    );

    gov_client.cast_vote(&voter, &proposal_id, &VoteType::For);

    e.ledger().set(LedgerInfo {
        timestamp: 1000 + voting_period + 1,
        protocol_version: 20,
        sequence_number: 20,
        network_id: Default::default(),
        base_reserve: 10,
        max_entry_ttl: 31536000,
        min_persistent_entry_ttl: 2592000,
        min_temp_entry_ttl: 16,
    });

    gov_client.update_proposal_status(&proposal_id);

    let proposal = gov_client.get_proposal(&proposal_id).unwrap();
    assert_eq!(proposal.status, ProposalStatus::Passed);
}

#[test]
fn test_approval_threshold_edge_case() {
    let e = Env::default();
    e.mock_all_auths();
    e.ledger().set(LedgerInfo {
        timestamp: 1000,
        protocol_version: 20,
        sequence_number: 10,
        network_id: Default::default(),
        base_reserve: 10,
        max_entry_ttl: 31536000,
        min_persistent_entry_ttl: 2592000,
        min_temp_entry_ttl: 16,
    });

    let (gov_client, admin, governance_token, token_client) = setup_governance(&e);
    let proposer = Address::generate(&e);
    let voter_for = Address::generate(&e);
    let voter_against = Address::generate(&e);

    e.mock_all_auths();
    token_client.mint(&proposer, &10000);
    token_client.mint(&voter_for, &66000);
    token_client.mint(&voter_against, &34000);

    gov_client.update_circulating_voting_power(&admin, &100000u128);

    let voting_period = 7 * 24 * 60 * 60; // 7 days (minimum valid period)
    let proposal_id = gov_client.create_proposal(
        &proposer,
        &String::from_str(&e, "Test"),
        &String::from_str(&e, "Test"),
        &voting_period,
        &ProposalType::ParameterChange,
        &None::<ProposalParameters>,
        &None::<Address>,
        &None::<Symbol>,
        &None::<Vec<Val>>,
    );

    gov_client.cast_vote(&voter_for, &proposal_id, &VoteType::For);
    gov_client.cast_vote(&voter_against, &proposal_id, &VoteType::Against);

    e.ledger().set(LedgerInfo {
        timestamp: 1000 + voting_period + 1,
        protocol_version: 20,
        sequence_number: 20,
        network_id: Default::default(),
        base_reserve: 10,
        max_entry_ttl: 31536000,
        min_persistent_entry_ttl: 2592000,
        min_temp_entry_ttl: 16,
    });

    gov_client.update_proposal_status(&proposal_id);

    let proposal = gov_client.get_proposal(&proposal_id).unwrap();
    assert_eq!(proposal.status, ProposalStatus::Passed);
}

#[test]
fn test_zero_circulating_power() {
    let e = Env::default();
    e.mock_all_auths();
    let (gov_client, admin, _, _) = setup_governance(&e);

    gov_client.update_circulating_voting_power(&admin, &0u128);
    // Should handle zero gracefully
}

#[test]
fn test_vote_weight_calculation_edge_cases() {
    let e = Env::default();
    e.mock_all_auths();
    e.ledger().set(LedgerInfo {
        timestamp: 1000,
        protocol_version: 20,
        sequence_number: 10,
        network_id: Default::default(),
        base_reserve: 10,
        max_entry_ttl: 31536000,
        min_persistent_entry_ttl: 2592000,
        min_temp_entry_ttl: 16,
    });

    let (gov_client, admin, governance_token, token_client) = setup_governance(&e);
    let user = Address::generate(&e);

    e.mock_all_auths();
    token_client.mint(&user, &1);
    let power = gov_client.get_vote_power(&user);
    assert_eq!(power, 1);

    gov_client.lock_for_escrow(&user, &1, &52);
    let power = gov_client.get_vote_power(&user);
    // Base: 0 (1 token locked), Escrow: 1 * 40000 / 10000 = 4
    assert_eq!(power, 4);
}
